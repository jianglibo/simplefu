/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package me.resp.simplefu;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import me.resp.simplefu.model.DeploymentEnv;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.ParseResult;

@Command(name = "simplefu", mixinStandardHelpOptions = true, version = "simplefu 1.0", description = "a companion tool for resp.me deployments")
public class App {
    public static final String DEPLOYMENT_ENV_FILENAME = "deployment.env.properties";
    @Option(names = {
            "--error-tolerance" }, description = "the level of tolerance before aborting the task. default: ${DEFAULT-VALUE}, means ZERO tolerance.")
    Integer errorTolerance = 0;

    @Option(names = "--ignore-missing-source", description = "ignore file not exists error.")
    boolean ignoreMissingSource;

    @Option(names = "--deployment-env-file", defaultValue = DEPLOYMENT_ENV_FILENAME, description = "the path of deployment.env.properties file.")
    Path deploymentEnvFile;

    @Command(mixinStandardHelpOptions = true, description = "copy all the files listed in a description file.")
    Integer copyfilelist(
            @Parameters(index = "0", paramLabel = "<filelist>", description = "the file contains the list.") String filelist,
            @Option(names = "--backup") boolean backup, @Option(names = "--override") boolean override)
            throws IOException {
        if (backup) {
            InputFileParser inputFileParser = InputFileParser.copyParser(filelist);
            VersionTask versionTask = new VersionTask(inputFileParser.parse());
            versionTask.startBackup();
        }
        InputFileParser inputFileParser = InputFileParser.copyParser(filelist);
        CopyTask task = new CopyTask(inputFileParser.parse(), override);
        task.start();
        return 0;
    }

    // /**
    //  * No default value. It's not a good idea to have a default value for this.
    //  * Sometimes we want to controll the behavior
    //  * precisely.
    //  * 
    //  * @param copyAlways
    //  * @param copyIfMissing
    //  * @return
    //  * @throws IOException
    //  */
    // @Command(name = "update", mixinStandardHelpOptions = true, description = "update the destination with the files in the list. and versionlize the destination.")
    // public Integer update(@Option(names = {
    //         "--copy-always" }, description = "the files in this list will be copied even if they already exist in the destination") String copyAlways,
    //         @Option(names = {
    //                 "--copy-if-missing" }, description = "the files in this list will be copied only if they do not exist in the destination") String copyIfMissing)
    //         throws IOException {
    //     if (copyAlways == null && copyIfMissing == null) {
    //         System.out.println("nothing to do");
    //         return 0;
    //     }
    //     boolean copyAlwaysExists = Files.exists(Path.of(copyAlways));
    //     boolean copyIfMissingExists = Files.exists(Path.of(copyIfMissing));
    //     if (!copyAlwaysExists && !copyIfMissingExists) {
    //         System.out.println("input files don't exist, nothing to do");
    //         return 0;
    //     }

    //     if (copyAlwaysExists) {
    //         InputFileParser inputFileParser = InputFileParser.copyParser(copyAlways);
    //         VersionTask versionTask = new VersionTask(inputFileParser.parse());
    //         versionTask.startBackup();

    //         inputFileParser = InputFileParser.copyParser(copyAlways);
    //         CopyTask task = new CopyTask(inputFileParser.parse(), true);
    //         task.start();
    //     }
    //     if (copyIfMissingExists) {
    //         InputFileParser inputFileParser = InputFileParser.copyParser(copyIfMissing);
    //         CopyTask task = new CopyTask(inputFileParser.parse(), false);
    //         task.start();
    //     }
    //     return 0;
    // }

    @Command(name = "rollback", mixinStandardHelpOptions = true, description = "rollback the destination with the files in the list.")
    public Integer rollback(
            @Parameters(index = "0", arity = "1..*", description = "files list the files to process.") List<String> inputFiles)
            throws IOException {
        inputFiles = inputFiles == null ? new ArrayList<>() : inputFiles;
        if (inputFiles.isEmpty()) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }
        VersionTask versionTask = new VersionTask(inputFiles.stream()
                .map(InputFileParser::restoreParser)
                .flatMap(ip -> {
                    return Util.exceptionHandler(() -> ip.parse(), Stream.empty(), 1, "parse filelistfile");
                }));
        versionTask.startRollback();
        return 0;
    }

    /**
     * 
     * @param deployment_downloads.txt
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    @Command(name = "download", mixinStandardHelpOptions = true, description = "download all files listed in the 'deployment_downloads.txt'")
    public Integer download(
            @Parameters(index = "0", arity = "0..1", description = "files list the files to process.") Path inputFile)
            throws IOException, InterruptedException {
        DeploymentEnv deploymentEnv = Util.loadDeploymentEnv(deploymentEnvFile);
        if (deploymentEnv == null) {
            System.out.println("deployment env file not found: " + deploymentEnvFile.toAbsolutePath());
            return 1;
        }
        if (inputFile == null) {
            PureHttpClient.downloadDeploymentDownloadsFromAzure(null, deploymentEnv.getServerRootUri(),
                    deploymentEnv.getShortTimePassword());
        } else {
            PureHttpClient.downloadDeploymentDownloadsFromAzureOneFile(null, inputFile,
                    deploymentEnv.getServerRootUri(),
                    deploymentEnv.getShortTimePassword()).collect(Collectors.toList());
        }
        return 0;
    }

    /**
     * No default value. It's not a good idea to have a default value for this.
     * Sometimes we want to controll the behavior
     * precisely.
     * 
     * @param copyAlways
     * @param copyIfMissing
     * @return
     * @throws IOException
     */
    // @Command(name = "copy", description = "copy files")
    // public Integer copy(@Option(names = {
    // "--copy-always" }, description = "the files in this list will be copied even
    // if they already exist in the destination") String copyAlways,
    // @Option(names = {
    // "--copy-if-missing" }, description = "the files in this list will be copied
    // only if they do not exist in the destination") String copyIfMissing)
    // throws IOException {
    // boolean copyAlwaysExists = Files.exists(Path.of(copyAlways));
    // boolean copyIfMissingExists = Files.exists(Path.of(copyIfMissing));
    // if (!copyAlwaysExists && !copyIfMissingExists) {
    // System.out.println("input files don't exist, nothing to do");
    // return 0;
    // }

    // if (copyAlwaysExists) {
    // InputFileParser inputFileParser = InputFileParser.copyParser(copyAlways);
    // CopyTask task = new CopyTask(inputFileParser.parse(), true);
    // task.start();
    // }
    // if (copyIfMissingExists) {
    // InputFileParser inputFileParser = InputFileParser.copyParser(copyIfMissing);
    // CopyTask task = new CopyTask(inputFileParser.parse(), false);
    // task.start();
    // }
    // return 0;
    // }

    /**
     * No default value. It's not a good idea to have a default value for this.
     * 
     * @throws InterruptedException
     */
    @Command(name = "backup", mixinStandardHelpOptions = true, description = "backup files")
    public Integer backup(@Option(names = {
            "--backup-to" }, paramLabel = "<filename>", description = "the zip file to store the backup.") String backupTo,
            @Option(names = {
                    "--upload-to-azure" }, description = "upload the zip file to azure and associate with this deployment.") boolean uploadToAzure,
            @Parameters(index = "0", arity = "1..*", paramLabel = "<filelistfiles>", description = "files which list the files to process.") List<String> inputFiles)
            throws IOException, InterruptedException {
        inputFiles = inputFiles == null ? new ArrayList<>() : inputFiles;
        if (inputFiles.isEmpty()) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }

        BackupRestoreTask backupRestoreTask = new BackupRestoreTask(
                inputFiles.stream()
                        .map(InputFileParser::restoreParser)
                        .flatMap(ip -> {
                            return Util.exceptionHandler(() -> ip.parse(), Stream.empty(), 1, "parse filelistfile");
                        }),
                backupTo == null ? null : Path.of(backupTo));
        Path backuped = backupRestoreTask.backup();
        if (uploadToAzure) {
            DeploymentEnv deploymentEnv = Util.loadDeploymentEnv(deploymentEnvFile);
            PureHttpClient.uploadToAzure(backuped, deploymentEnv.getServerRootUri(),
                    deploymentEnv.getShortTimePassword(), 10, "azureblob");
        }
        return 0;
    }

    /**
     * No default value. It's not a good idea to have a default value for this.
     * 
     * @param backupFile
     * @param inputFiles
     * @return
     * @throws IOException
     */
    @Command(name = "restore", mixinStandardHelpOptions = true, description = "restore files")
    public Integer restore(@Option(names = {
            "--restore-from" }, description = "the zip file to restore from.") String backupFile,
            @Parameters(index = "0", arity = "1..*", description = "files list the files to process.") List<String> inputFiles)
            throws IOException {
        inputFiles = inputFiles == null ? new ArrayList<>() : inputFiles;
        if (inputFiles.isEmpty()) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }
        BackupRestoreTask backupRestoreTask = new BackupRestoreTask(
                inputFiles.stream()
                        .map(InputFileParser::restoreParser)
                        .flatMap(ip -> {
                            return Util.exceptionHandler(() -> ip.parse(), Stream.empty(), 1, "parse filelistfile");
                        }),
                Path.of(backupFile));
        backupRestoreTask.restore();
        return 0;
    }

    @Command(name = "unzip", mixinStandardHelpOptions = true, description = "do unzip")
    public Integer unzip(@Option(names = {
            "--to-dir" }, description = "extracted files go this directory.") Path toDir,
            @Parameters(index = "0", arity = "1", description = "files list the files to process.") Path zipFile)
            throws IOException {
        Util.unzipTo(zipFile, toDir);
        return 0;
    }

    private int executionStrategy(ParseResult parseResult) {
        Util.errorTolerance = errorTolerance;
        Util.setIgnoreMissingSource(ignoreMissingSource);
        // System.out.printf("errorTolerance: %d, ignoreMissingSource: %s%n",
        // errorTolerance, ignoreMissingSource);
        return new CommandLine.RunLast().execute(parseResult); // default execution strategy
    }

    public static void main(String[] args) {
        try {
            App app = new App();
            int exitCode = new CommandLine(app).setExecutionStrategy(app::executionStrategy).execute(args);
            System.exit(exitCode);
        } finally {
            ZipTask.clearCache();
        }
    }
}
