/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package me.resp.simplefu;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.stream.Stream;

import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.ParseResult;

@Command(name = "simplefu", mixinStandardHelpOptions = true, version = "simplefu 1.0", description = "a companion tool for resp.me deployments")
public class App implements Callable<Integer> {

    protected static final String COPY_ALWAYS_FILENAME = "copy-always.txt";
    protected static final String COPY_IF_MISSING_FILENAME = "copy-if-missing.txt";

    @Option(names = {
            "--error-tolerance" }, description = "the level of tolerance before aborting the task. default: ${DEFAULT-VALUE}, means ZERO tolerance.")
    Integer errorTolerance = 0;

    @Option(names = "--ignore-missing-source", description = "create a new archive")
    boolean ignoreMissingSource;

    @Command(name = "copy", description = "copy files")
    public Integer copy(@Option(names = {
            "--copy-always" }, defaultValue = COPY_ALWAYS_FILENAME, description = "the files in this list will be copied even if they already exist in the destination") String copyAlways,

            @Option(names = {
                    "--copy-if-missing" }, defaultValue = COPY_IF_MISSING_FILENAME, description = "the files in this list will be copied only if they do not exist in the destination") String copyIfMissing)
            throws IOException {
        boolean copyAlwaysExists = Files.exists(Path.of(copyAlways));
        boolean copyIfMissingExists = Files.exists(Path.of(copyIfMissing));
        if (!copyAlwaysExists && !copyIfMissingExists) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }

        if (copyAlwaysExists) {
            InputFileParser inputFileParser = new InputFileParser(copyAlways);
            CopyTask task = new CopyTask(inputFileParser.parse(), true);
            task.start();
        }
        if (copyIfMissingExists) {
            InputFileParser inputFileParser = new InputFileParser(copyIfMissing);
            CopyTask task = new CopyTask(inputFileParser.parse(), false);
            task.start();
        }
        return 0;
    }

    @Command(name = "backup", description = "backup files")
    public Integer backup(@Option(names = {
            "--backup-to" }, description = "the zip file to store the backup.") String backupTo,
            @Parameters(index = "0", arity = "0..*", description = "files which list the files to process.") List<String> inputFiles)
            throws IOException {
        Util.ignoreMissingSource = true;
        inputFiles = inputFiles == null ? new ArrayList<>() : inputFiles;
        if (inputFiles.isEmpty()) {
            if (Files.exists(Path.of(COPY_ALWAYS_FILENAME))) {
                inputFiles.add(COPY_ALWAYS_FILENAME);
            }
            if (Files.exists(Path.of(COPY_IF_MISSING_FILENAME))) {
                inputFiles.add(COPY_IF_MISSING_FILENAME);
            }
        }

        if (inputFiles.isEmpty()) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }

        BackupRestoreTask backupRestoreTask = new BackupRestoreTask(
                inputFiles.stream()
                        .map(InputFileParser::new)
                        .flatMap(ip -> {
                            return Util.exceptionHandler(() -> ip.parse(), Stream.empty(), 1, "parse filelistfile");
                        }),
                backupTo == null ? null : Path.of(backupTo));
        backupRestoreTask.backup();
        return 0;
    }

    @Command(name = "restore", description = "restore files")
    public Integer restore(@Option(names = {
            "--restore-from" }, description = "the zip file to restore from.") String backupFile,
            @Parameters(index = "0", arity = "0..*", description = "files list the files to process.") List<String> inputFiles)
            throws IOException {
        Util.ignoreMissingSource = true;
        inputFiles = inputFiles == null ? new ArrayList<>() : inputFiles;
        if (inputFiles.isEmpty()) {
            if (Files.exists(Path.of(COPY_ALWAYS_FILENAME))) {
                inputFiles.add(COPY_ALWAYS_FILENAME);
            }
            if (Files.exists(Path.of(COPY_IF_MISSING_FILENAME))) {
                inputFiles.add(COPY_IF_MISSING_FILENAME);
            }
        }

        if (inputFiles.isEmpty()) {
            System.out.println("input files don't exist, nothing to do");
            return 0;
        }
        BackupRestoreTask backupRestoreTask = new BackupRestoreTask(
                inputFiles.stream()
                        .map(InputFileParser::new)
                        .flatMap(ip -> {
                            return Util.exceptionHandler(() -> ip.parse(), Stream.empty(), 1, "parse filelistfile");
                        }),
                Path.of(backupFile));
        backupRestoreTask.restore();
        return 0;
    }

    @Override
    public Integer call() throws Exception { // your business logic goes here...
        System.out.println("Subcommand needed: 'copy', 'backup' or 'restore'");
        return 0;
    }

    private int executionStrategy(ParseResult parseResult) {
        Util.errorTolerance = errorTolerance;
        Util.ignoreMissingSource = ignoreMissingSource;
        return new CommandLine.RunLast().execute(parseResult); // default execution strategy
    }

    public static void main(String[] args) {
        try {
            App app = new App();
            int exitCode = new CommandLine(app).setExecutionStrategy(app::executionStrategy).execute(args);
            System.exit(exitCode);
        } finally {
            ZipTask.clearCache();
        }
    }
}
